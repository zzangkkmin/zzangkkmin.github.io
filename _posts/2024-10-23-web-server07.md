---  
layout: post  
title: "Server 07 - DB Locks"  
subtitle: "DB Locks"  
categories: web  
tags: [server]   
comments: true   
# header-img: img/review/2019-11-22-review-book-pycharm-1.jpg  
---  
  
## DB에서 Lock? 
뒷 단 작업하면서 데이터가 왔다리 갔다리 하는 데에 신경을 많이 써야 한다. 특히 동일한 자료를 동시에 사용할 때 주의해야 한다. 이를 DB에서 여러 트랜잭션이 같은 자원에 동시에 접근 했을 때라 하며 줄여서 **경쟁 상태**라 한다. 이러한 경쟁 상태가 되었을 시, 데이터 충돌이나 불일치 현상이 발생되기 때문에 경쟁 상태를 막아줘야 한다. 이 막아주는 행동 매커니즘을 DB에선 **LOCK**이라 한다.

락은 트랜잭션이 진행되는 동안 특정 데이터를 보호하기 위해 다른 트랜잭션이 그 데이터에 동시에 접근하거나 수정하지 못하게 하는 역할을 맡는다. 즉 Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법이다.

## Lock의 종류
- **공유락 또는 읽기락** (Shared Lock or Read Lock)  
  데이터를 읽을 때 사용, 공유 락은 공유 락끼라 동시에 접근 가능  
  하나의 데이터를 읽는 것은 여러 사용자가 동시에 가능은 하나, 공유락에 걸린 데이터에 베타락을 사용할 수 없다. 
- **베타락 또는 쓰기락** (Exclusive Lock or Write Lock)  
  데이터를 변경할 때 사용, 베타락은 락이 해제될 때까지 다른 트랜잭션는 해당 리소스에 접근 못 함.
  
## Lock 설정 범위
접근을 제한하는 락도 범위를 지정할 수 있다. 큰 공간을 차지하는 개념부터 내림차순으로 설정할 수 있으며 다음과 같다.
- 데이터베이스
- 파일
- 테이블
- 행

## Lock으로 인한 막힘 현상들: 블록킹 & 데드락
**블록킹**: 하나의 트랜잭션이 데이터를 사용하여 Lock이 걸렸을 때 Lock간(베타 - 베타, 베타 - 공유)의 경합이 발행하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춰선 상태를 말한다. 블로킹을 해소하기 위해서는 이전의 트랜잭션이 커밋되거나 롤백되어야 한다. 뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능하다.

**데드락**: 두 트랜잭션이 서로가 필요로 하는 자원에 대해 Lock을 잡고 있어, 서로 상대방의 작업이 완료되기만을 기다리며 무한히 대기하는 상태. 즉, 영원히 해결되지 않는 교착 상태를 말한다. 블록킹과 달리 두 프로세스/트랜잭션이 진행 불가능 상태인지라, 강제로 한 트랙잭션을 종료하여야 해결이 가능하다.

|**구분**|**블로킹(Blocking)**|**데드락(Deadlock)**|
|--------|-------------------|--------------------|
|**정의**|하나의 트랜잭션이 자원을 점유하는 동안 다른 트랜잭션이 대기|서로 다른 트랜잭션이 상대방이 점유한 자원을 기다리며 무한 대기 상태|
|**해결 가능성**|선행 트랜잭션이 완료되면 대기 중인 트랜잭션이 실행 가능|시스템이 감지하지 못하면 대기 상태가 계속되어 자동 해결 불가|
|**대기 상태**| 일시적인 대기 상태, 자원이 해제되면 대기가 끝남|무한 대기 상태, 시스템이 개입하지 않으면 해결되지 않음|
|**발생 원인**| 하나의 트랜잭션이 자원을 점유하고 있을 때 다른 트랜잭션이 접근 시도| 두 트랜잭션이 서로가 점유한 자원을 필요로 하여 발생|
|**해결 방법**| 선행 트랜잭션이 완료되면 자동 해결| 트랜잭션 중 하나를 강제 종료하여 교착 상태를 해제해야 함|

## Lock의 전략들: 낙관적 락 & 비관적 락
DB에서 경쟁상태를 해결해 주는 락을 이용하여 동시성 문제를 해결하는 전략은 두 가지가 있다.

### 낙관적 락

**충돌이 자주 발생하지 않을 것이라는 가정**하에 동작하는 락 방식. 여러 트랜잭션이 동시에 데이터를 읽고 쓸 수 있지만, 트랜잭션 완료 시점에서 데이터의 변경 여부를 검증하여 충돌이 발생했을 때만 처리하는 방식. 실제로는 물리적인 락을 걸지 않으며, 주로 **버전 관리(Versioning)**를 통해 변경 여부를 확인한다.

특징:
- 데이터베이스에서 물리적인 락을 걸지 않음.
- 트랜잭션이 데이터에 접근하여 작업을 완료한 후, 변경 사항을 커밋할 때 다른 트랜잭션이 해당 데이터를 수정했는지 여부를 검사.
- 주로 버전 번호나 타임스탬프를 사용하여 충돌을 감지.
- 충돌 발생 시, 해당 트랜잭션을 롤백하고 다시 시도.

예시:
1. 트랜잭션 A와 트랜잭션 B가 같은 데이터 읽음.
2. 트랜잭션 A가 해당 데이터를 수정하고 커밋하려 할 때, 데이터의 버전 번호(또는 타임스탬프)를 확인.
3. 트랜잭션 B가 이미 해당 데이터를 수정하고 커밋한 경우, 트랜잭션 A는 충돌을 감지하고 롤백.
4. 그리고 트랜잭션 A는 다시 시도해야 합니다.

장점:
- 동시성 성능이 뛰어남: 물리적 락이 없어 동시 접근에 유리, 충돌이 자주 발생하지 않는 환경에서 성능 좋음.
- 락 오버헤드 X: 물리적으로 데이터에 대한 잠금을 걸지 않기 때문에 성능 저하가 발생 X.

단점:
- 충돌이 발생할 경우 재시도 필요: 충돌이 발생하면 해당 트랜잭션은 다시 시도해야 하므로, 충돌이 잦은 환경에서는 비효율적.

### 비관적 락
**충돌이 자주 발생할 것이라는 가정**하에 데이터를 보호하는 방식. 트랜잭션이 데이터를 수정하거나 읽기 전에 먼저 물리적인 잠금을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하게 블로킹. 비관적 락은 데이터에 대한 독점적인 접근을 보장하며, 주로 **공유 락(Shared Lock)**과 **배타 락(Exclusive Lock)**을 사용.

특징:
- 데이터를 읽거나 수정하기 전 물리적으로 락을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 설정.
- 동시성 처리에 제약이 있으며, 충돌이 발생하지 않도록 사전에 예방.
- 트랜잭션이 완료되거나 락이 해제되기 전까지 다른 트랜잭션이 대기 상태에 돌입.

예시:
1. 트랜잭션 A가 데이터를 읽거나 수정하려 할 때 락을 걸고, 트랜잭션 A가 완료될 때까지 다른 트랜잭션은 해당 데이터에 접근 불가.
2. 트랜잭션 B가 같은 데이터를 수정하려고 시도하면, 락이 해제될 때까지 대기

장점:
- 데이터 충돌 방지: 데이터를 수정하기 전에 락을 걸어 충돌을 완벽히 예방
- 안정적인 처리: 데이터 무결성과 일관성을 보장하며, 데이터의 손상 가능성을 최소화.
  
단점:
- 동시성 저하: 락이 걸리는 동안 다른 트랜잭션이 대기해야 하므로, 동시성이 크게 저하될 수 있습니다.
- 데드락 발생 가능: 여러 트랜잭션이 서로를 기다리며 교착 상태(데드락)에 빠질 수 있음.

### 요약
|**구분**|**낙관적 락 (Optimistic Lock)**|**비관적 락 (Pessimistic Lock)**|
|--------|------------------------------|--------------------------------|
|**기본 개념**|충돌이 자주 발생하지 않을 것이라 가정하고, 충돌 시 롤백 후 처리| 충돌이 자주 발생할 것이라 가정하고, 미리 락을 걸어 충돌 방지|
|**락 적용 시점**| 데이터 수정 후 커밋할 때 충돌 여부 확인| 데이터 접근 전(읽기 또는 쓰기 시점)에 락을 먼저 걸음|
|**물리적 락**| 없음 (논리적 검사로 처리)| 있음 (실제 락을 걸어 다른 트랜잭션의 접근을 막음)|
|**성능**| 동시성에 유리하며 락 오버헤드가 적음| 동시성이 낮아지고, 대기 시간이 길어질 수 있음|
|**충돌 처리 방식**| 충돌 발생 시 트랜잭션을 롤백하고 다시 시도| 충돌 자체를 예방, 충돌이 발생하지 않도록 함|
|**적합한 상황**| 읽기가 많고, 쓰기 작업이 드문 환경| 쓰기 작업이 많고, 충돌이 빈번히 발생할 가능성이 큰 환경|


## 결론
DB에서 **LOCK**이란 트랜잭션이 동시에 같은 데이터에 접근하여 의도치 않게 변형되는 것을 막는 개념이다. **읽기/공유 락**과 **쓰기/베타 락**으로 구분되어 있으며, 뒷 단에서 DB를 관리 및 개선할 때 경쟁 상태를 막는 방법과 그로 인한 **블로킹**이나 **데드락** 같은 충돌을 방지하다가 나온 부작용이 발생하지 않도록 전략을 짜야한다. 케이스 바이 케이스겠지만, 두가지로 나눠서 **낙관적 락**과 **비관적 락**으로 DB의 동시성 처리 문제를 해결할 수 있다. 